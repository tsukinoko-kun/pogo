// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: query.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const addFileToChange = `-- name: AddFileToChange :exec
INSERT INTO change_files (change_id, file_id)
VALUES ($1, $2)
`

// AddFileToChange
//
//	INSERT INTO change_files (change_id, file_id)
//	VALUES ($1, $2)
func (q *Queries) AddFileToChange(ctx context.Context, changeID int64, fileID int64) error {
	_, err := q.db.Exec(ctx, addFileToChange, changeID, fileID)
	return err
}

const checkIfChangesSameFileCount = `-- name: CheckIfChangesSameFileCount :one
SELECT
    (SELECT COUNT(a.file_id) FROM change_files AS a WHERE a.change_id = $1) =
    (SELECT COUNT(b.file_id) FROM change_files AS b WHERE b.change_id = $2) AS have_same_number_of_files
`

// CheckIfChangesSameFileCount
//
//	SELECT
//	    (SELECT COUNT(a.file_id) FROM change_files AS a WHERE a.change_id = $1) =
//	    (SELECT COUNT(b.file_id) FROM change_files AS b WHERE b.change_id = $2) AS have_same_number_of_files
func (q *Queries) CheckIfChangesSameFileCount(ctx context.Context, changeID int64, changeID_2 int64) (bool, error) {
	row := q.db.QueryRow(ctx, checkIfChangesSameFileCount, changeID, changeID_2)
	var have_same_number_of_files bool
	err := row.Scan(&have_same_number_of_files)
	return have_same_number_of_files, err
}

const clearChange = `-- name: ClearChange :exec
DELETE FROM change_files WHERE change_id = $1
`

// ClearChange
//
//	DELETE FROM change_files WHERE change_id = $1
func (q *Queries) ClearChange(ctx context.Context, changeID int64) error {
	_, err := q.db.Exec(ctx, clearChange, changeID)
	return err
}

const copyFileList = `-- name: CopyFileList :exec
INSERT INTO change_files (change_id, file_id)
SELECT $1, file_id
FROM change_files
AS old
WHERE old.change_id = $2
`

// CopyFileList
//
//	INSERT INTO change_files (change_id, file_id)
//	SELECT $1, file_id
//	FROM change_files
//	AS old
//	WHERE old.change_id = $2
func (q *Queries) CopyFileList(ctx context.Context, newID int64, oldID int64) error {
	_, err := q.db.Exec(ctx, copyFileList, newID, oldID)
	return err
}

const createChange = `-- name: CreateChange :one
INSERT INTO changes (repository_id, name, description, author, device, depth)
VALUES ($1, $2, $3, $4, $5, $6)
RETURNING id
`

// CreateChange
//
//	INSERT INTO changes (repository_id, name, description, author, device, depth)
//	VALUES ($1, $2, $3, $4, $5, $6)
//	RETURNING id
func (q *Queries) CreateChange(ctx context.Context, repositoryID int32, name string, description *string, author string, device string, depth int64) (int64, error) {
	row := q.db.QueryRow(ctx, createChange,
		repositoryID,
		name,
		description,
		author,
		device,
		depth,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const createRepo = `-- name: CreateRepo :one
INSERT INTO repositories (name)
VALUES ($1)
RETURNING id
`

// CreateRepo
//
//	INSERT INTO repositories (name)
//	VALUES ($1)
//	RETURNING id
func (q *Queries) CreateRepo(ctx context.Context, name string) (int32, error) {
	row := q.db.QueryRow(ctx, createRepo, name)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const findChangeExact = `-- name: FindChangeExact :one
SELECT id, repository_id, name, description, author, device, depth, created_at, updated_at FROM changes WHERE repository_id = $1 AND name = $2 LIMIT 1
`

// FindChangeExact
//
//	SELECT id, repository_id, name, description, author, device, depth, created_at, updated_at FROM changes WHERE repository_id = $1 AND name = $2 LIMIT 1
func (q *Queries) FindChangeExact(ctx context.Context, repositoryID int32, name string) (Change, error) {
	row := q.db.QueryRow(ctx, findChangeExact, repositoryID, name)
	var i Change
	err := row.Scan(
		&i.ID,
		&i.RepositoryID,
		&i.Name,
		&i.Description,
		&i.Author,
		&i.Device,
		&i.Depth,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getAllBookmarks = `-- name: GetAllBookmarks :many
SELECT id, repository_id, name, change_id FROM bookmarks
WHERE repository_id = $1 
    AND bookmarks.name NOT LIKE '__head-%'
`

// GetAllBookmarks
//
//	SELECT id, repository_id, name, change_id FROM bookmarks
//	WHERE repository_id = $1
//	    AND bookmarks.name NOT LIKE '__head-%'
func (q *Queries) GetAllBookmarks(ctx context.Context, repositoryID int32) ([]Bookmark, error) {
	rows, err := q.db.Query(ctx, getAllBookmarks, repositoryID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Bookmark
	for rows.Next() {
		var i Bookmark
		if err := rows.Scan(
			&i.ID,
			&i.RepositoryID,
			&i.Name,
			&i.ChangeID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAncestryOfChange = `-- name: GetAncestryOfChange :many
WITH RECURSIVE ancestry AS (
  -- Base case: the target change
  SELECT $1::bigint AS id
  UNION
  -- Recursive case: find all ancestors
  SELECT cr.parent_id
  FROM ancestry a
  JOIN change_relations cr
    ON cr.change_id = a.id
  WHERE cr.parent_id IS NOT NULL
)
SELECT
  c.id, c.repository_id, c.name, c.description, c.author, c.device, c.depth, c.created_at, c.updated_at,
  cr.parent_id,
  cr.change_id
FROM ancestry a
JOIN changes c
  ON c.id = a.id
LEFT JOIN change_relations cr
  ON cr.change_id = c.id
WHERE c.repository_id = $3::integer
LIMIT $2
`

type GetAncestryOfChangeRow struct {
	ID           int64
	RepositoryID int32
	Name         string
	Description  *string
	Author       string
	Device       string
	Depth        int64
	CreatedAt    pgtype.Timestamptz
	UpdatedAt    pgtype.Timestamptz
	ParentID     *int64
	ChangeID     *int64
}

// GetAncestryOfChange
//
//	WITH RECURSIVE ancestry AS (
//	  -- Base case: the target change
//	  SELECT $1::bigint AS id
//	  UNION
//	  -- Recursive case: find all ancestors
//	  SELECT cr.parent_id
//	  FROM ancestry a
//	  JOIN change_relations cr
//	    ON cr.change_id = a.id
//	  WHERE cr.parent_id IS NOT NULL
//	)
//	SELECT
//	  c.id, c.repository_id, c.name, c.description, c.author, c.device, c.depth, c.created_at, c.updated_at,
//	  cr.parent_id,
//	  cr.change_id
//	FROM ancestry a
//	JOIN changes c
//	  ON c.id = a.id
//	LEFT JOIN change_relations cr
//	  ON cr.change_id = c.id
//	WHERE c.repository_id = $3::integer
//	LIMIT $2
func (q *Queries) GetAncestryOfChange(ctx context.Context, column1 int64, limit int32, column3 int32) ([]GetAncestryOfChangeRow, error) {
	rows, err := q.db.Query(ctx, getAncestryOfChange, column1, limit, column3)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAncestryOfChangeRow
	for rows.Next() {
		var i GetAncestryOfChangeRow
		if err := rows.Scan(
			&i.ID,
			&i.RepositoryID,
			&i.Name,
			&i.Description,
			&i.Author,
			&i.Device,
			&i.Depth,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ParentID,
			&i.ChangeID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getBookmark = `-- name: GetBookmark :one
SELECT change_id FROM bookmarks WHERE repository_id = $1 AND name = $2 LIMIT 1
`

// GetBookmark
//
//	SELECT change_id FROM bookmarks WHERE repository_id = $1 AND name = $2 LIMIT 1
func (q *Queries) GetBookmark(ctx context.Context, repositoryID int32, name string) (int64, error) {
	row := q.db.QueryRow(ctx, getBookmark, repositoryID, name)
	var change_id int64
	err := row.Scan(&change_id)
	return change_id, err
}

const getChangeConflicts = `-- name: GetChangeConflicts :many
SELECT files.name
FROM change_files
INNER JOIN files ON files.id = change_files.file_id
WHERE change_files.change_id = $1 AND files.conflict = true
`

// GetChangeConflicts
//
//	SELECT files.name
//	FROM change_files
//	INNER JOIN files ON files.id = change_files.file_id
//	WHERE change_files.change_id = $1 AND files.conflict = true
func (q *Queries) GetChangeConflicts(ctx context.Context, changeID int64) ([]string, error) {
	rows, err := q.db.Query(ctx, getChangeConflicts, changeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var name string
		if err := rows.Scan(&name); err != nil {
			return nil, err
		}
		items = append(items, name)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getChangeDepth = `-- name: GetChangeDepth :one
SELECT depth FROM changes WHERE id = $1 AND repository_id = $2 LIMIT 1
`

// GetChangeDepth
//
//	SELECT depth FROM changes WHERE id = $1 AND repository_id = $2 LIMIT 1
func (q *Queries) GetChangeDepth(ctx context.Context, iD int64, repositoryID int32) (int64, error) {
	row := q.db.QueryRow(ctx, getChangeDepth, iD, repositoryID)
	var depth int64
	err := row.Scan(&depth)
	return depth, err
}

const getChangeDescription = `-- name: GetChangeDescription :one
SELECT description FROM changes WHERE id = $1 LIMIT 1
`

// GetChangeDescription
//
//	SELECT description FROM changes WHERE id = $1 LIMIT 1
func (q *Queries) GetChangeDescription(ctx context.Context, id int64) (*string, error) {
	row := q.db.QueryRow(ctx, getChangeDescription, id)
	var description *string
	err := row.Scan(&description)
	return description, err
}

const getChangeIgnorefiles = `-- name: GetChangeIgnorefiles :many
SELECT files.name, files.content_hash FROM files
INNER JOIN change_files ON change_files.file_id = files.id
WHERE change_files.change_id = $1
`

type GetChangeIgnorefilesRow struct {
	Name        string
	ContentHash []byte
}

// GetChangeIgnorefiles
//
//	SELECT files.name, files.content_hash FROM files
//	INNER JOIN change_files ON change_files.file_id = files.id
//	WHERE change_files.change_id = $1
func (q *Queries) GetChangeIgnorefiles(ctx context.Context, changeID int64) ([]GetChangeIgnorefilesRow, error) {
	rows, err := q.db.Query(ctx, getChangeIgnorefiles, changeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetChangeIgnorefilesRow
	for rows.Next() {
		var i GetChangeIgnorefilesRow
		if err := rows.Scan(&i.Name, &i.ContentHash); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getChangeName = `-- name: GetChangeName :one
SELECT name FROM changes WHERE id = $1 AND repository_id = $2 LIMIT 1
`

// GetChangeName
//
//	SELECT name FROM changes WHERE id = $1 AND repository_id = $2 LIMIT 1
func (q *Queries) GetChangeName(ctx context.Context, iD int64, repositoryID int32) (string, error) {
	row := q.db.QueryRow(ctx, getChangeName, iD, repositoryID)
	var name string
	err := row.Scan(&name)
	return name, err
}

const getChangeOwner = `-- name: GetChangeOwner :one
SELECT author, device FROM changes WHERE id = $1 LIMIT 1
`

type GetChangeOwnerRow struct {
	Author string
	Device string
}

// GetChangeOwner
//
//	SELECT author, device FROM changes WHERE id = $1 LIMIT 1
func (q *Queries) GetChangeOwner(ctx context.Context, id int64) (GetChangeOwnerRow, error) {
	row := q.db.QueryRow(ctx, getChangeOwner, id)
	var i GetChangeOwnerRow
	err := row.Scan(&i.Author, &i.Device)
	return i, err
}

const getChangePrefix = `-- name: GetChangePrefix :one
WITH RECURSIVE lengths_series(l) AS (
  SELECT 1
  UNION ALL
  SELECT l + 1
  FROM lengths_series
  WHERE l < 64
)
SELECT
  (SUBSTRING(
     c.name
     FROM 1 FOR (
       SELECT ls.l
       FROM lengths_series AS ls
       WHERE ls.l <= CHAR_LENGTH(c.name)
         AND NOT EXISTS (
           SELECT 1
           FROM changes AS c_other
           WHERE c.id != c_other.id
             AND c.repository_id = c_other.repository_id
             AND SUBSTRING(c.name FROM 1 FOR ls.l)
               = SUBSTRING(c_other.name FROM 1 FOR ls.l)
         )
       ORDER BY ls.l
       LIMIT 1
     )
   )::TEXT) AS unique_identifier
FROM changes AS c
WHERE c.id = $1
  AND c.repository_id = $2
LIMIT 1
`

// GetChangePrefix
//
//	WITH RECURSIVE lengths_series(l) AS (
//	  SELECT 1
//	  UNION ALL
//	  SELECT l + 1
//	  FROM lengths_series
//	  WHERE l < 64
//	)
//	SELECT
//	  (SUBSTRING(
//	     c.name
//	     FROM 1 FOR (
//	       SELECT ls.l
//	       FROM lengths_series AS ls
//	       WHERE ls.l <= CHAR_LENGTH(c.name)
//	         AND NOT EXISTS (
//	           SELECT 1
//	           FROM changes AS c_other
//	           WHERE c.id != c_other.id
//	             AND c.repository_id = c_other.repository_id
//	             AND SUBSTRING(c.name FROM 1 FOR ls.l)
//	               = SUBSTRING(c_other.name FROM 1 FOR ls.l)
//	         )
//	       ORDER BY ls.l
//	       LIMIT 1
//	     )
//	   )::TEXT) AS unique_identifier
//	FROM changes AS c
//	WHERE c.id = $1
//	  AND c.repository_id = $2
//	LIMIT 1
func (q *Queries) GetChangePrefix(ctx context.Context, iD int64, repositoryID int32) (string, error) {
	row := q.db.QueryRow(ctx, getChangePrefix, iD, repositoryID)
	var unique_identifier string
	err := row.Scan(&unique_identifier)
	return unique_identifier, err
}

const getRepoByName = `-- name: GetRepoByName :one
SELECT id FROM repositories WHERE name = $1 LIMIT 1
`

// GetRepoByName
//
//	SELECT id FROM repositories WHERE name = $1 LIMIT 1
func (q *Queries) GetRepoByName(ctx context.Context, name string) (int32, error) {
	row := q.db.QueryRow(ctx, getRepoByName, name)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const hasChangeChild = `-- name: HasChangeChild :one
SELECT EXISTS (
    SELECT 1
    FROM change_relations
    WHERE parent_id = $1
)
`

// HasChangeChild
//
//	SELECT EXISTS (
//	    SELECT 1
//	    FROM change_relations
//	    WHERE parent_id = $1
//	)
func (q *Queries) HasChangeChild(ctx context.Context, parentID *int64) (bool, error) {
	row := q.db.QueryRow(ctx, hasChangeChild, parentID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const hasChangeConflicts = `-- name: HasChangeConflicts :one
SELECT EXISTS (
    SELECT 1
    FROM change_files
    INNER JOIN files ON files.id = change_files.file_id
    WHERE change_files.change_id = $1 AND files.conflict = true
    LIMIT 1
)
`

// HasChangeConflicts
//
//	SELECT EXISTS (
//	    SELECT 1
//	    FROM change_files
//	    INNER JOIN files ON files.id = change_files.file_id
//	    WHERE change_files.change_id = $1 AND files.conflict = true
//	    LIMIT 1
//	)
func (q *Queries) HasChangeConflicts(ctx context.Context, changeID int64) (bool, error) {
	row := q.db.QueryRow(ctx, hasChangeConflicts, changeID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const listChangeFiles = `-- name: ListChangeFiles :many
SELECT files.name, files.executable, files.content_hash FROM change_files
INNER JOIN files ON files.id = change_files.file_id
WHERE change_files.change_id = $1
`

type ListChangeFilesRow struct {
	Name        string
	Executable  bool
	ContentHash []byte
}

// ListChangeFiles
//
//	SELECT files.name, files.executable, files.content_hash FROM change_files
//	INNER JOIN files ON files.id = change_files.file_id
//	WHERE change_files.change_id = $1
func (q *Queries) ListChangeFiles(ctx context.Context, changeID int64) ([]ListChangeFilesRow, error) {
	rows, err := q.db.Query(ctx, listChangeFiles, changeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListChangeFilesRow
	for rows.Next() {
		var i ListChangeFilesRow
		if err := rows.Scan(&i.Name, &i.Executable, &i.ContentHash); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const setBookmark = `-- name: SetBookmark :exec
INSERT INTO bookmarks (repository_id, name, change_id)
VALUES ($1, $2, $3)
ON CONFLICT (repository_id, name)
DO UPDATE SET change_id = $3
`

// SetBookmark
//
//	INSERT INTO bookmarks (repository_id, name, change_id)
//	VALUES ($1, $2, $3)
//	ON CONFLICT (repository_id, name)
//	DO UPDATE SET change_id = $3
func (q *Queries) SetBookmark(ctx context.Context, repositoryID int32, name string, changeID int64) error {
	_, err := q.db.Exec(ctx, setBookmark, repositoryID, name, changeID)
	return err
}

const setChangeDepth = `-- name: SetChangeDepth :exec
UPDATE changes
SET depth = $2
WHERE id = $1
`

// SetChangeDepth
//
//	UPDATE changes
//	SET depth = $2
//	WHERE id = $1
func (q *Queries) SetChangeDepth(ctx context.Context, iD int64, depth int64) error {
	_, err := q.db.Exec(ctx, setChangeDepth, iD, depth)
	return err
}

const setChangeDescription = `-- name: SetChangeDescription :exec
UPDATE changes
SET description = $2, updated_at = CURRENT_TIMESTAMP, author = $3, device = $4
WHERE id = $1
`

// SetChangeDescription
//
//	UPDATE changes
//	SET description = $2, updated_at = CURRENT_TIMESTAMP, author = $3, device = $4
//	WHERE id = $1
func (q *Queries) SetChangeDescription(ctx context.Context, iD int64, description *string, author string, device string) error {
	_, err := q.db.Exec(ctx, setChangeDescription,
		iD,
		description,
		author,
		device,
	)
	return err
}

const setChangeParent = `-- name: SetChangeParent :exec
INSERT INTO change_relations (change_id, parent_id)
VALUES ($1, $2)
ON CONFLICT (change_id, parent_id)
DO NOTHING
`

// SetChangeParent
//
//	INSERT INTO change_relations (change_id, parent_id)
//	VALUES ($1, $2)
//	ON CONFLICT (change_id, parent_id)
//	DO NOTHING
func (q *Queries) SetChangeParent(ctx context.Context, changeID int64, parentID *int64) error {
	_, err := q.db.Exec(ctx, setChangeParent, changeID, parentID)
	return err
}

const findChanges = `-- name: findChanges :many
SELECT DISTINCT c.id
FROM changes AS c
LEFT JOIN bookmarks AS b
    ON b.change_id = c.id AND b.repository_id = c.repository_id
WHERE c.repository_id = $1
    AND (c.name LIKE $2::text || '%' OR b.name = $2::text)
LIMIT $3
`

// findChanges
//
//	SELECT DISTINCT c.id
//	FROM changes AS c
//	LEFT JOIN bookmarks AS b
//	    ON b.change_id = c.id AND b.repository_id = c.repository_id
//	WHERE c.repository_id = $1
//	    AND (c.name LIKE $2::text || '%' OR b.name = $2::text)
//	LIMIT $3
func (q *Queries) findChanges(ctx context.Context, repositoryID int32, search string, limit int32) ([]int64, error) {
	rows, err := q.db.Query(ctx, findChanges, repositoryID, search, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int64
	for rows.Next() {
		var id int64
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
